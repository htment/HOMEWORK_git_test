1. git clone git@github.com:netology-code/sys-pattern-homework.git
2. git init - инициализируем репозиторий
3. git config --global init.defaultBranch main
4. git branch --show  показать теущую ветку 
  git checkout -b  master создать новую ветку и переключиться на нее
5. git status  статус
6. git diff --staged показать изменения
7. git add README.md Перевел файл в состояние staged:
---еще раз смотрим изменения
8. git diff
  изменения в git
   git diff --staged
9. git add .

10. git remote add origin git@github.com:htment/HOMEWORK_git_test.git подключаем удаленный репозиторий
11. git remote -v просмотр удаленных репозиториев
12. git push origin master пушим в ветку master

новая ветка
git checkout -b dev

. Создал в ветке dev файл test.sh с произвольным содержимым:
echo "#!/bin/bash" > test.sh
echo "echo 'Hello from dev.'" >> test.sh
chmod +x test.sh

несколько коммитов и пушей в ветку dev
git add test.sh
git commit -m "Add test.sh with greetings"
echo "echo 'Second line from dev.'" >> test.sh
git add test.sh
git commit -m "Update test.sh - add second line"
git push origin dev


git push --set-upstream origin dev в Git используется для отправки локальной ветки dev на 
git branch -d branchName — безопасное удаление: ветка будет если был merge
git branch -D branchName — принудительное удаление


git checkout -p test test.sh - один файл


git rebase -i <хеш_коммита_перед_тем_который_нужно_изменить>
 git rebase -i (интерактивный rebase):  Это самый распространённый и гибкий способ.  Он позволяет редактировать историю коммитов.
  Вы можете внести необходимые изменения в файлы, закоммитить их (возможно, с новым сообщением) и продолжить rebase командой git rebase --continue. 
  
Измените команду на reword, edit или squash:  В редакторе вы увидите список коммитов, которые будут затронуты rebase. Найдите коммит, который нужно изменить, и измените команду перед ним с pick на:

    * reword:  Позволяет изменить сообщение коммита.
    * edit: Позволяет изменить как сообщение коммита, так и сами файлы.  Это наиболее подходящий вариант, если нужно изменить содержимое коммита.
    * squash:  Объединяет этот коммит с предыдущим.

.  git revert более безопасен в этом отношении.  Если вы не уверены, лучше использовать git revert.

создать подреппозиторий
git submodule add git@github.com:netology-code/sdvps-materials.git sdvps-materials

Удалить файл из истории
git filter-branch --index-filter 'git rm --cached --ignore-unmatch go1.17.5.linux-amd64.tar.gz' --prune-empty --tag-name-filter cat -- --all
    * --index-filter:  Эта опция указывает, что нужно выполнить команду git rm для удаления файла из индекса (staging area) каждого коммита.
   * git rm --cached --ignore-unmatch go1.17.5.linux-amd64.tar.gz:  Эта команда удаляет файл из индекса, игнорируя ошибки, если файл не найден в коммите.
   * --prune-empty:  Эта опция удаляет пустые коммиты, которые могут возникнуть после удаления файла.
   * --tag-name-filter cat:  Эта опция обрабатывает теги, чтобы избежать проблем с ними.
   * --all:  Эта опция указывает, что нужно обработать все ветки.
    
  . Удалите старую историю:  После завершения filter-branch, старая история всё ещё может суще   старая история всё ещё может существовать, если вы к нему обращаетесь напрямую
   git reflog expire --expire=now --all
   git gc --prune=now --aggressive
   git push origin --force --all
   git push origin --force --tags


## Посмотерть историю
git log
git log -p Выводит реальные изменения (диф) в каждом коммите



Если вам нужно вернуться к старому коммиту в Git, существует несколько способов сделать это, в зависимости от вашей цели: временно проверить старый коммит, создать новую ветку на его основе или полностью откатить изменения в основной ветке. Вот основные методы:

1. Проверка старого коммита (Detached HEAD)

Если вы просто хотите временно просмотреть старый коммит, вы можете выполнить git checkout с указанием хеша коммита:
Bash


git checkout <commit-hash>

Замените <commit-hash> на фактический хеш коммита (можно использовать первые 7 символов хеша). В этом режиме ваш репозиторий будет находиться в состоянии "detached HEAD", что значит, что вы не находитесь ни в одной из веток. Если вы сделаете изменения и хотите их сохранить, вам нужно будет создать новую ветку.

2. Вернуться на старый коммит (с сохранением изменений)

Если вы хотите переместить вашу ветку на старый коммит и сохранить все изменения, сделанные после него, вы можете выполнить git reset:
Bash


git reset --soft <commit-hash>

Это переместит указатель вашей текущей ветки на старый коммит, но сохранит все изменения в рабочем каталоге и в индексе. После этого вы можете сделать новый коммит с любой комбинацией изменений или оставить их для настройки.

3. Полный откат до старого коммита (если изменения не нужны)

Если вы хотите полностью откатиться до старого коммита и удалить все последующие изменения, используйте:
Bash


git reset --hard <commit-hash>

Эта команда приведет ваш текущий репозиторий к состоянию, как если бы вы никогда не вносили изменения после указанного коммита. Будьте осторожны: все несохраненные изменения будут потеряны.

4. Создание новой ветки от старого коммита

Если вы хотите сохранить изменения, но начать новую ветку с этого коммита:
Bash


git checkout -b new-branch-name <commit-hash>

Это создаст новую ветку new-branch-name, начиная с указанного коммита.

5. Использование git revert для отмены изменений

Если вы хотите отменить изменения, сделанные конкретным коммитом, вы можете использовать git revert:
Bash


git revert <commit-hash>

Это создаст новый коммит, который отменяет изменения указанного коммита, сохраняя при этом всю историю версий.

Заключение

Выбор метода зависит от ваших целей: временно просмотреть старый коммит, начать новую ветку, сохранить изменения или полностью откатиться. Всегда важно убедиться, что все важные изменения сохранены или зафиксированы перед выполнением операций, которые могут изменить историю коммитов!
   
